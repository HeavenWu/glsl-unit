// Copyright 2011 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Generates glsl code from an ast generated by glsl.pegjs.
 * @author rowillia@google.com (Roy Williams)
 */

goog.provide('glslunit.Generator');

goog.require('glslunit.ASTVisitor');



/**
 * Creates a glsl source code generater from an ast.
 * @param {string=} opt_newline_str The character to use when printing newlines.
 *     This is useful for printing to JavaScript code vs. a normal shader file.
 * @param {boolean=} opt_debug Whether or not to generate more human readable
 *     code.
 * @constructor
 * @extends {glslunit.ASTVisitor}
 * @export
 */
glslunit.Generator = function(opt_newline_str, opt_debug) {
  goog.base(this);

  /**
   * The character to use when printing newlines.
   * @type {string}
   * @private
   * @const
   */
  this.newline_str_ = opt_newline_str || '\n';

  /**
   * Whether or not to generate more human readable code.
   * @type {boolean}
   * @private
   * @const
   */
  this.debug_ = !!opt_debug;

  /**
   * The current source code.
   * @type {string}
   * @private
   */
  this.sourceCode_ = '';

  /**
   * If we're outputting debug code, the current indentation.
   * @type {number}
   * @private
   */
   this.currentIndent_ = 0;
};
goog.inherits(glslunit.Generator, glslunit.ASTVisitor);


/**
 * The string to use when indenting a new line.
 * @type {string}
 * @private
 * @const
 */
glslunit.Generator.INDENT_STR_ = '  ';

/**
 * The precedence of all of the operators in GLSL.  Operators with lower
 * values should be executed first and thus have a higher precedence.
 * @const
 */
glslunit.Generator.OrderOfOperations = {
  'function_call': 0, 'identifier': 0, 'float': 0, 'int': 0, 'bool': 0,
  'postfix': 1,
  'unary': 2,
  '*': 3, '/': 3, '%': 3,
  '+': 4, '-': 4,
  '<<': 5, '>>': 5,
  '<': 6, '>': 6, '<=': 6, '>=': 6,
  '==': 7, '!=': 7,
  '&': 8,
  '^': 9,
  '|': 10,
  '&&': 11,
  '||': 12,
  'ternary': 13
};


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @return {number} The precedence of node.
 */
glslunit.Generator.getNodePrecedence = function(node) {
  if (node.type == 'binary') {
    return glslunit.Generator.OrderOfOperations[node.operator.operator];
  } else {
    return glslunit.Generator.OrderOfOperations[node.type];
  }
};


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @param {string=} opt_newline_str The character to use when printing newlines.
 *     This is useful for printing to JavaScript code vs. a normal shader file.
 * @param {boolean=} opt_debug Whether or not to generate more human readable
 *     code.
 * @return {string} The source code for this node.
 */
glslunit.Generator.getSourceCode = function(node, opt_newline_str, opt_debug) {
  var generator = new glslunit.Generator(opt_newline_str, opt_debug);
  generator.visitNode(node);
  return generator.sourceCode_;
};


/**
 * Checks to see if value is defined, and if it is returns pre + value + post.
 * @param {string} pre If value isn't null, the string to add before value.
 * @param {string?} value The value to check to see if it's null and
 *     return.
 * @param {string} post If value isn't null, the string to add after value.
 * @return {string} The source code.
 */
glslunit.Generator.prototype.checkAndAdd = function(pre, value, post) {
  if (value) {
    return pre + value + post;
  }
  return '';
};


/**
 * @param {Array.<Object>} nodes The nodes to print to sourceCode.
 * @param {string} joinStr The string to print between each node we print.
 * @private
 */
glslunit.Generator.prototype.addNodesWithJoin_ = function(nodes, joinStr) {
  for (var i = 0; i < nodes.length; i++) {
    if (i != 0) {
      this.sourceCode_ += joinStr;
    }
    this.visitNode(nodes[i]);
  }
};


/**
 * Print a newline and indent the next line of we're in debug mode.
 * @private
 */
glslunit.Generator.prototype.maybePrintNewline = function() {
  if (this.debug_) {
    this.sourceCode_ +=
        this.newline_str_ + (new Array(this.currentIndent_ + 1)).
                            join(glslunit.Generator.INDENT_STR_);
  }
};


/**
 * If we're in debug mode, chop off the last indent
 * @private
 */
glslunit.Generator.prototype.maybeUnindent = function() {
  if (this.debug_ &&
      this.sourceCode_.slice(-1 * glslunit.Generator.INDENT_STR_.length) ==
        glslunit.Generator.INDENT_STR_) {
    // If we're outputting in debug mode, de-indent the last brace to be in the
    // correct spot.
    this.sourceCode_ =
        this.sourceCode_.slice(0, -1 * glslunit.Generator.INDENT_STR_.length);
  }
};


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitStructDefinition = function(node) {
  this.sourceCode_ += this.checkAndAdd('', node.qualifier, ' ');
  this.sourceCode_ += 'struct';
  this.sourceCode_ += this.checkAndAdd(' ', node.name, '');
  this.sourceCode_ += '{';
  this.currentIndent_++;
  this.addNodesWithJoin_(node.members, '');
  this.currentIndent_--;
  this.maybeUnindent();
  this.sourceCode_ += '}';
  if (node.declarators) {
    this.addNodesWithJoin_(node.declarators, ',');
  }
  this.sourceCode_ += ';';
  this.maybePrintNewline();
};


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitScope = function(node) {
  this.sourceCode_ += '{';
  this.currentIndent_++;
  this.maybePrintNewline();
  this.addNodesWithJoin_(node.statements, '');
  this.currentIndent_--;
  this.maybeUnindent();
  this.sourceCode_ += '}';
  this.maybePrintNewline();
};


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitPrecision = function(node) {
  this.sourceCode_ += 'precision ' + node.precision + ' ' +
                       node.typeName + ';';
  this.maybePrintNewline();
};


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitInvariant = function(node) {
 this.sourceCode_ += 'invariant ';
 this.addNodesWithJoin_(node.identifiers, ',');
 this.sourceCode_ += ';';
 this.maybePrintNewline();
};


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitParameter = function(node) {
  this.sourceCode_ += this.checkAndAdd('', node.typeQualifier, ' ');
  this.sourceCode_ += this.checkAndAdd('', node.parameterQualifier, ' ');
  this.sourceCode_ += this.checkAndAdd('', node.precision, ' ');
  this.sourceCode_ += node.type_name + ' ' + node.name;
  if (node.arraySize) {
    this.sourceCode_ += '[';
    this.visitNode(node.arraySize);
    this.sourceCode_ += ']';
  }
};


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @private
 */
glslunit.Generator.prototype.generateFunctionPrototype_ = function(node) {
  this.visitNode(node.returnType);
  this.sourceCode_ += ' ' + node.name + '(';
  this.addNodesWithJoin_(node.parameters, ',');
  this.sourceCode_ += ')';
};


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitFunctionPrototype = function(node) {
  this.generateFunctionPrototype_(node);
  this.sourceCode_ += ';';
  this.maybePrintNewline();
};


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitFunctionDeclaration = function(node) {
  this.generateFunctionPrototype_(node);
  this.visitNode(node.body);
};


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitPreprocessor = function(node) {
  var lastChars = this.sourceCode_.slice(-1 * this.newline_str_.length);
  if (lastChars && lastChars != this.newline_str_) {
    this.sourceCode_ += this.newline_str_;
  }
  this.sourceCode_ += node.directive;
  this.sourceCode_ += this.checkAndAdd(' ', node.value, '');
  this.sourceCode_ += this.newline_str_;
  if (node.guarded_statements) {
    this.addNodesWithJoin_(node.guarded_statements, '');
    if (node.elseBody) {
      this.visitNode(node.elseBody);
    }
    if (node.directive.slice(0, 3) == '#if') {
      lastChars = this.sourceCode_.slice(-1 * this.newline_str_.length);
      if (lastChars != this.newline_str_) {
        this.sourceCode_ += this.newline_str_;
      }
      this.sourceCode_ += '#endif' + this.newline_str_;
    }
  }
};


/**
 * Generates the while statement for a do or while node.
 * @param {!Object} node The node of the AST having its source code generated.
 * @private
 */
glslunit.Generator.prototype.generateWhile_ = function(node) {
  this.sourceCode_ += 'while(';
  this.visitNode(node.condition);
  this.sourceCode_ += ')';
};


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitDoStatement = function(node) {
  this.sourceCode_ += 'do ';
  this.visitNode(node.body);
  this.generateWhile_(node);
};


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitWhileStatement = function(node) {
  this.generateWhile_(node);
  this.visitNode(node.body);
};


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitForStatement = function(node) {
  this.sourceCode_ += 'for(';
  // We don't need to add a semicolon after the initializer because it will
  // always be parsed as an expression_statement or a declarator, both of
  // which require a trailing semi-colon.
  this.visitNode(node.initializer);
  this.visitNode(node.condition);
  this.sourceCode_ += ';';
  this.visitNode(node.increment);
  this.sourceCode_ += ')';
  this.visitNode(node.body);
};


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitIfStatement = function(node) {
  this.sourceCode_ += 'if(';
  this.visitNode(node.condition);
  this.sourceCode_ += ')';
  this.visitNode(node.body);
  if (node.elseBody) {
    this.sourceCode_ += 'else ';
    this.visitNode(node.elseBody);
  }
};


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitDeclaratorItem = function(node) {
  this.visitNode(node.name);
  if (node.isArray) {
    this.sourceCode_ += '[';
    if (node.arraySize) {
      this.visitNode(node.arraySize);
    }
    this.sourceCode_ += ']';
  }
  if (node.initializer) {
    this.sourceCode_ += '=';
    this.visitNode(node.initializer);
  }
};


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitDeclarator = function(node) {
  this.visitNode(node.typeAttribute);
  this.sourceCode_ += ' ';
  this.addNodesWithJoin_(node.declarators, ',');
  this.sourceCode_ += ';';
  this.maybePrintNewline();
};


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitType = function(node) {
  this.sourceCode_ += this.checkAndAdd('', node.qualifier, ' ');
  this.sourceCode_ += this.checkAndAdd('', node.precision, ' ');
  this.sourceCode_ += node.name;
};


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitExpression = function(node) {
  this.visitNode(node.expression);
  this.sourceCode_ += ';';
  this.maybePrintNewline();
};


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitJump = function(node) {
  this.sourceCode_ += node.type;
  if (node.value) {
    this.sourceCode_ += ' ';
    this.visitNode(node.value);
  }
  this.sourceCode_ += ';';
  this.maybePrintNewline();
};


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitReturn =
  glslunit.Generator.prototype.visitJump;


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitBreak =
  glslunit.Generator.prototype.visitJump;


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitDiscard =
  glslunit.Generator.prototype.visitJump;


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitContinue =
  glslunit.Generator.prototype.visitJump;


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitUnary = function(node) {
  var nodePrecedence = glslunit.Generator.getNodePrecedence(node);
  // In cases like "10- -1, we need to add the space between the '10-' and the
  // '-1' to prevent confusion.  Otherwise, it gets interpreted as
  // (10--)1, which won't compile.
  if (this.sourceCode_.slice(-1) == node.operator.operator) {
    this.sourceCode_ += ' ';
  }
  this.visitNode(node.operator);
  this.maybeParenthiseNode_(node.expression, nodePrecedence);
};


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitPostfix = function(node) {
  var nodePrecedence = glslunit.Generator.getNodePrecedence(node);
  this.maybeParenthiseNode_(node.expression, nodePrecedence);
  this.visitNode(node.operator);
};


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitOperator = function(node) {
  this.sourceCode_ += node.operator;
};


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitFieldSelector = function(node) {
  this.sourceCode_ += '.' + node.selection;
};


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitAccessor = function(node) {
  this.sourceCode_ += '[';
  this.visitNode(node.index);
  this.sourceCode_ += ']';
};


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitFunctionCall = function(node) {
  this.sourceCode_ += node.function_name + '(';
  this.addNodesWithJoin_(node.parameters, ',');
  this.sourceCode_ += ')';
};


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitIdentifier = function(node) {
  this.sourceCode_ += node.name;
};


/**
 * Formats a number as a GLSL float.
 * @param {number} value The number to format as a GLSL float.
 * @return {string} The float formatted as a GLSL float.
 */
glslunit.Generator.formatFloat = function(value) {
  if (value == 0) {
    return '0.';
  }
  var floatStr = ('' + value).toLowerCase().replace('+', '');
  if (floatStr.indexOf('.') == -1 && floatStr.indexOf('e') == -1) {
    floatStr += '.';
  }
  // Strip leading and trailing 0's
  return floatStr.replace(/^0*|0*$/g, '');
};


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitFloat = function(node) {
  this.sourceCode_ += glslunit.Generator.formatFloat(node.value);
};


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitValue = function(node) {
  this.sourceCode_ += node.value;
};


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitInt = glslunit.Generator.prototype.visitValue;


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitBool =
  glslunit.Generator.prototype.visitValue;


/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitBinary = function(node) {
  var nodePrecedence = glslunit.Generator.getNodePrecedence(node);
  this.maybeParenthiseNode_(node.left, nodePrecedence);
  this.visitNode(node.operator);
  this.maybeParenthiseNode_(node.right, nodePrecedence);
};

/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @protected
 * @export
 */
glslunit.Generator.prototype.visitTernary = function(node) {
  var nodePrecedence = glslunit.Generator.getNodePrecedence(node);
  this.maybeParenthiseNode_(node.condition, nodePrecedence);
  this.sourceCode_ += '?';
  this.maybeParenthiseNode_(node.is_true, nodePrecedence);
  this.sourceCode_ += ':';
  this.maybeParenthiseNode_(node.is_false, nodePrecedence);
};

/**
 * @param {!Object} node The node of the AST having its source code generated.
 * @param {number} parentPrecedence The precedence of the parent node.
 * @private
 */
glslunit.Generator.prototype.maybeParenthiseNode_ = function(node,
                                                            parentPrecedence) {
  var nodePrecedence = glslunit.Generator.getNodePrecedence(node);
  if (nodePrecedence > parentPrecedence) {
    this.sourceCode_ += '(';
  }
  this.visitNode(node);
  if (nodePrecedence > parentPrecedence) {
    this.sourceCode_ += ')';
  }
};
